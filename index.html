<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>天井高さメジャー（WebXR / Pixel向け）</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family: system-ui, -apple-system, sans-serif; }
    #hud{
      position:fixed; left:12px; top:12px; z-index:10;
      background:rgba(0,0,0,.58); color:#fff; padding:10px 12px; border-radius:12px;
      max-width: calc(100% - 24px); line-height:1.35;
    }
    #row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    #state { font-weight:700; }
    #vals { margin-top:6px; font-size:14px; }
    #vals b { font-size:16px; }
    button{ border:0; border-radius:10px; padding:8px 10px; cursor:pointer; }
    #note{ margin-top:8px; font-size:12px; opacity:.9; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="row">
      <div>手順: <span id="state">AR開始 → 床をタップ</span></div>
      <button id="reset">リセット</button>
    </div>
    <div id="vals">
      天井高(垂直): <b id="h">—</b><br/>
      2点間(斜め): <span id="d">—</span> / 水平ズレ: <span id="xy">—</span>
    </div>
    <div id="note">
      コツ: 最初に床や壁をゆっくり見回して空間認識が安定してから天井へ。<br/>
      天井が真っ白/暗いと当たりにくいので、照明を明るめに。
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js";

    const stateEl = document.getElementById("state");
    const hEl = document.getElementById("h");
    const dEl = document.getElementById("d");
    const xyEl = document.getElementById("xy");
    const resetBtn = document.getElementById("reset");

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

    // Reticle
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.06, 0.085, 32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({ color: 0x00ff99 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Points + visuals
    const points = [];
    const pointMeshes = [];
    let line = null;

    const pointGeom = new THREE.SphereGeometry(0.012, 16, 16);
    const pointMat  = new THREE.MeshStandardMaterial({ color: 0xffcc00 });

    function clearMeasure(){
      points.length = 0;
      pointMeshes.forEach(m => scene.remove(m));
      pointMeshes.length = 0;
      if (line){ scene.remove(line); line.geometry.dispose(); line.material.dispose(); line = null; }
      hEl.textContent = "—";
      dEl.textContent = "—";
      xyEl.textContent = "—";
      stateEl.textContent = "AR開始 → 床をタップ";
    }
    resetBtn.addEventListener("click", clearMeasure);

    // Hit-test
    let hitTestSource = null;
    let viewerSpace = null;
    let refSpace = null;

    async function initHitTest(session){
      viewerSpace = await session.requestReferenceSpace("viewer");
      // まず local-floor を試し、ダメなら local にフォールバック
      try {
        refSpace = await session.requestReferenceSpace("local-floor");
      } catch {
        refSpace = await session.requestReferenceSpace("local");
      }
      hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

      session.addEventListener("end", () => {
        hitTestSource = null; viewerSpace = null; refSpace = null;
        clearMeasure();
      });
    }

    const controller = renderer.xr.getController(0);
    controller.addEventListener("select", () => {
      if (!reticle.visible) return;

      const p = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);

      // 3回目タップでやり直し
      if (points.length >= 2) clearMeasure();

      points.push(p);

      const pm = new THREE.Mesh(pointGeom, pointMat);
      pm.position.copy(p);
      scene.add(pm);
      pointMeshes.push(pm);

      if (points.length === 1){
        stateEl.textContent = "次に天井をタップ";
      } else if (points.length === 2){
        const p0 = points[0], p1 = points[1];
        const straight = p0.distanceTo(p1);
        const vertical = Math.abs(p1.y - p0.y);
        const horizontal = Math.hypot(p1.x - p0.x, p1.z - p0.z);

        hEl.textContent = vertical.toFixed(3) + " m";
        dEl.textContent = straight.toFixed(3) + " m";
        xyEl.textContent = horizontal.toFixed(3) + " m";
        stateEl.textContent = "完了（必要ならリセット）";

        const geom = new THREE.BufferGeometry().setFromPoints([p0, p1]);
        const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
        line = new THREE.Line(geom, mat);
        scene.add(line);
      }
    });
    scene.add(controller);

    // AR Button
    document.body.appendChild(ARButton.createButton(renderer, {
      requiredFeatures: ["hit-test", "dom-overlay"],
      domOverlay: { root: document.body }
    }));

    renderer.xr.addEventListener("sessionstart", async () => {
      await initHitTest(renderer.xr.getSession());
    });

    renderer.setAnimationLoop((t, frame) => {
      if (frame && hitTestSource && refSpace){
        const results = frame.getHitTestResults(hitTestSource);
        if (results.length){
          const pose = results[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }
      renderer.render(scene, camera);
    });

    window.addEventListener("resize", () => renderer.setSize(window.innerWidth, window.innerHeight));
  </script>
</body>
</html>
